# 动态代理知识

## 代理机制

代理模式（Proxy）：**为其他对象提供一个代理以控制对这个对象的访问**。（某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用）

()与代理类实现同一个接口，代理类通过复写接口中的方法，在该方法中调用被代理类的方法，实现被代理类功能的扩展。

---

## 静态代理

### 静态代理类**完成的功能**

1. 被代理类中方法的调用
2. 功能增强

静态代理由程序员或代码生成工具生成代理类，编译之后生成Class文件，代理关系在编译期就已经绑定，一个代理关系是一个代理类对应一个基础接口

### 静态代理的**两个缺点**

* 重复性，在程序规模稍大时，需要代理的方法越多，重复的模板代码就越多；（一个被代理类可能有多个代理类，那么增加被代理类可能就成倍增加代理类）
* 脆弱性，基础接口一旦改动，除了所有业务类需要改动外，代理类也必须改动(代理类必须重写接口的全部方法  

---

## jdk的反射机制

概念:在程序运行时，程序有能力获取一个类的所有方法和属性；并且对于任意一个对象，可以调用它的任意方法或者获取其属性

---

## 动态代理

### 概念

动态代理：在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态地指定要代理的被代理类。

### 特点

1. 不用创建代理类
2. 可以给不同的被代理类创建代理

### 两种实现方式

1. JDK的动态代理：
    利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
    使用Java反射包中的类和接口实现动态代理的功能。java.lang.reflect(InvocationHandler,Method,Proxy)
2. CGLIB动态代理（了解）:
    利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
    cglib的原理是继承，通过继承被代理类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。
3. 字节码方式（JBASS）
### JDK动态代理

JDK动态代理的实现：
    java.lang.reflect反射包  
    最主要的三个类--InvocationHandler,Method,Proxy
    Proxy:代理类
    InvocationHandler：调用处理程序类

#### InvocationHandler接口

* InvocationHandle接口（调用处理器）：唯一方法     invoke()
Invoke():表示代理对象要执行的功能代码。代理类要完成的功能就写在invoke()中

    ```java
    //Object proxy:被代理的对象--dk创建的代理对象，无需复制
    //Method method:要调用的方法 ---被代理类中的方法，jdk提供method对象的
    //Object[] args:方法调用时所需要参数 --被代理类中方法的参数，jdk提供
    public interface InvocationHandler {
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
    }
    ```

* 代理类完成的功能
    1. 调用目标方法，执行目标方法的功能
    2. 功能增强，在目标方法调用时，增加功能

* 怎么用（InvocationHandle接口表示你的代理要干什么）
  * 创建类实现接口InvocationHandler
  * 重写invoke()方法，把原理静态代理中代理类要完成的功能写在这

#### Method类

* Method类：通过Method可以执行某个被代理类的方法
* 用法：Method.invoke(目标对象，方法的参数)

#### Proxy类

* Proxy类
  核心的对象，创建代理对象。代替之前new方法创建对象

* Proxy类,静态方法newProxyInstance()

    ```java
    //CLassLoader loader:被代理对象的类加载器，负责向内存中加载对象
    //Class<?> interfaces:被代理类全部的接口 
    //InvocationHandler h:实现InvocationHandler接口的对象 
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces, 
                                          InvocationHandler h) 
    ```

* 看法
动态代理最主要是减少我们的代码量
按常规来说为每个被代理类编写相应的代理类很繁琐
对于为什么不一个代理类不代理多个被代理类，我想应该是资源的问题，从业务层面可能只需要某几个代理类，代理类代理多个被代理类一次性初始化了很多代理的是及其浪费资源的。
动态代理的反射机制就是对资源的节约
动态代理proxy类，是对所有代理类的抽象，抽象是能够大大减少我们代码的编写的。
如果说光有抽象的proxy类，我们确实可以减少每个具体代理类的代码编写，但是依旧要为每个被代理类编写对应的代理类，因为需要某种代理类就去new出来，所以代理类必须硬编码保存起来。
而反射机制能够让我们在需要的时候动态编写出来

---

## 动态代理与静态代理区别

### 共同点

两种代理模式实现都在不改动基础对象的前提下，对基础对象进行访问控制和扩展，符合开闭原则。

### 不同点

静态代理在程序规模稍大时，重复性和脆弱性的缺点凸显；
动态代理（搭配**泛型参数**）实现了一个代理同时处理N多个基础接口，本质上是代理类和基础接口的解耦，一定程度上规避了静态代理的缺点。从原理上讲，静态代理的代理类Class文件在编译期生成，而动态代理的代理类Class文件在运行时生成，代理类在coding阶段并不存在，代理关系直到运行时才确定。

通过泛型参数传递不同的类型，客户端可以按需实例化不同类型的代理对象。基础接口的所有方法都统一到InvocationHandler#invoke() 处理，即使有多个基础业务需要代理，也不需要编写过多重复的模板代码；当基础接口变更时，同步改动代理并不是必须的，从而规避了重复性和脆弱性。

如果有人指着你的程序说：“不是代理模式！这里少了一个接口”，你会乖乖点头吗？提醒一下，设计模式本身并不是目的，解决问题才是。不要为了设计而设计！---实现了功能即是代理模式

## 动态代理的实际运用常见

1. 你所在的项目中，有一个功能是其他人（公司其它部门，其他小组的人）写好的，你可以使用。但发现这个功能不足够 满足我的项目需要

## 问题合集

1. 静态代理是否每个被代理类必须配一个代理类，一个代理类为什么不代理所以代理类
2. 为什么能够自动执行invoke()
3. obj.method(para) 如何传参给newProxyInstance的
4. 为每个被代理类创建代理类，与执行时候再动态创建代理类比，动态好在哪里
