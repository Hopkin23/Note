# 面试题 视频课

## 面向对象的理解

* 对比面向过程，是两种不同的处理问题角度。面向过程注重事情的步骤和顺序，而面向对象关注有哪些参与者及其各自做些什么。面向过程--**高效**；面向对象--**复用、扩展和维护**
* 面向对象三大特性:封装，继承，多态
  * 封装：内部细节对外部调用者透明，调用者无需关心内部实现。
    * javabean属性私有，提供getset对外访问
    * orm框架，操作数据库不需要关系链接如何建立和sql如何执行，只需要引入mybatis调方法
  * 继承:继承基类的方法，做出自己的扩展。共性的方法减少了冗余。
  * 多态:基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
    * **三大条件**：继承 ，方法重写，父类引用指向子类对象

## ==与equals

==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址
equals:object中默认也是采用==比较，通常会重写
String通常能比较内部值是因为重写了equals方法

## final作用

**类**不可被继承；**方法**不可被子类覆盖，但是可以重载；**变量**一旦被赋值就不可以更改它的值

* 成员变量:声明时候，代码块中，构造器赋值
* 静态成员变量（类变量）：声明时候，静态代码块中赋值
* 局部变量:系统不会为程序变量初始化，局部变量必须有程序员显示初始化。可以声明时候不初始化
* 基本类型：初始化后不能修改
* 引用类型:初始化后不再指向另一个对象

## 为什么局部内部类和匿名内部类只能访问局部final变量

class{
    method{
        **final** var;
        class{}
}}
内部类 .java编译后生成两个class文件，内部类为了使用访问局部变量会复制局部变量到成员变量中，但是内部类的这个变量和方法的成员变量会出现一致性问题。
若局部变量改变，copy的值就不一致。copy值改变，局部变量同样。
若局部变量销毁，copy不能改变，我们不能改变一个被销毁的变量。

## String StringBuffer  StringBuilder

String 字符串常量---String 使用final修饰的字符数组
StringBuffer 字符串变量（线程安全）--AbstractStringBuilder
StringBuilder 字符串变量（非线程安全）--AbstractStringBuilder
性能:StringBuilder>StringBuilder>String
使用总结

1. 操作少量的数据：String
2. 单线程操作字符串缓冲区下操作大量数据: StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: StringBuilder

## 接口和抽象类

 相同点：
（1）都不能被实例化
（2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

不同点：
（1）接口只有定义，存在public abstract方法，**不能有方法的实现**，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
（2）实现接口的关键字为implements，继承抽象类的关键字为extends。**抽象类单继承，接口多实现。**
（3）接口强调特定功能的实现，而抽象类强调所属关系。
（4）接口**成员变量**默认为public static final，必须赋初值，不能被修改；其所有的**成员方法**都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。
（5）接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。

接口设计目的：对类的行为进行约束，只约束行为的有无，不关心如何实现---like a
抽象类目的:代码复用。将子类们的共性抽象为抽象类---is a
接口作用：
1、Java单继承的原因所以需要曲线救国 作为继承关系的一个补充。
2、把程序模块进行固化的契约,降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。（依赖倒置原则）
3、定义接口有利于代码的规范。（接口分离原则）

使用场景:
当关注一个事物本质时候，用抽象类；
当关注一个事物操作时候，用接口。
